import * as bip39 from 'bip39'
import * as bip32 from 'bip32'
import * as HID from 'node-hid'
import * as crypto from '../src/crypto/Key'
import Network from '../src/crypto/Network'

import {
  getPublicWalletAddress,
  signVergeTransaction,
  buildNewTransaction,
  sigHashType,
} from '../src/crypto/LedgerVerge'
import withLibcore from '../src/crypto/helpers/withLibcore'

const generateAddressFromPubKey = pubKey => {
  const pubKeyHash = crypto.getPublicKeyHash(pubKey)
  return crypto.createAddress(pubKeyHash, Network.verge.pubKeyHash)
}

test('generates the correct seed lengths', () => {
  expect(crypto.generateRandomSeed().length).toBe(32)
})

test('penetration test on buffer random lenght', () => {
  expect(crypto.generateRandomSeed(512).length).toBe(512)
})

test('bip39 mnemonic should reverse into the intial seed', () => {
  const seedFromMnemonic = bip39.mnemonicToSeed(
    'differ device enforce defy dove ice rebuild million escape sea wash rigid',
  )

  // Root Node
  const node = bip32.fromSeed(seedFromMnemonic)
  // first child
  const keySet = node.derivePath('m/0/0')
  // 10th children
  const keySetTwo = node.derivePath('m/0/10')

  expect(generateAddressFromPubKey(keySet.publicKey)).toBe(
    'DHbLUf28dQo3qkFBzp3WmtJFVQXMB7irif',
  )

  expect(generateAddressFromPubKey(keySetTwo.publicKey)).toBe(
    'D7fTZyn2TunQrMqZKyS7377v7ySypjMKTe',
  )
})

test('Generate Mnemonic from random secure seed', () => {
  const sixteenSecret = crypto.generateRandomSeed(16)
  const twentySecret = crypto.generateRandomSeed(20)
  const twentyFourSecret = crypto.generateRandomSeed(24)

  const mnemonicSixteen = bip39.entropyToMnemonic(sixteenSecret)
  const mnemonicTwenty = bip39.entropyToMnemonic(twentySecret)
  const mnemonicTwentyfour = bip39.entropyToMnemonic(twentyFourSecret)

  expect(mnemonicSixteen.split(' ').length).toBe(12)
  expect(mnemonicTwenty.split(' ').length).toBe(15)
  expect(mnemonicTwentyfour.split(' ').length).toBe(18)

  expect(bip39.mnemonicToEntropy(mnemonicSixteen)).toBe(
    sixteenSecret.toString('hex'),
  )
  expect(bip39.mnemonicToEntropy(mnemonicTwenty)).toBe(
    twentySecret.toString('hex'),
  )
  expect(bip39.mnemonicToEntropy(mnemonicTwentyfour)).toBe(
    twentyFourSecret.toString('hex'),
  )
})

/*test('Check if verge address is correctly being generated by the ledger wallet', () => {
  // get a currently connected NANO S
  const device = HID.devices().find(
    device => device.product && device.product.includes('Nano S'),
  )
  // Check if there's any nanos
  expect(device).not.toBeUndefined()

  // get his path
  const devicePath = device.path
  expect(typeof devicePath).toBe('string')

  expect.assertions(2)
  getPublicWalletAddress({
    devicePath,
    path: `44'/0'/0'/0`,
  })
    .then(({ address }: { address: string }) => {
      expect(typeof address).toBe('string')
      expect(address.length).toBe(34)
      console.log('VERGE ADDRESS:', address)
    })
    .catch(console.error)
})*/

test('Check if verge address is correctly being generated by the ledger wallet', () => {
  // expect.assertions(3)

  // get a currently connected NANO S
  const device = HID.devices().find(
    device => device.product && device.product.includes('Nano S'),
  )
  // Check if there's any nanos
  expect(device).not.toBeUndefined()

  // get his path
  const devicePath = device.path
  expect(typeof devicePath).toBe('string')

  withLibcore(core => {
    console.log(core)
    expect(core).not.toBeNull()
    /*signVergeTransaction(
      devicePath,
      'verge',
      buildNewTransaction(
        'account1',
        0,
        core,
        1000,
        0.001,
        'D9hXi8peL7AnuGxQZBZNVjq8GQWJJQg9FA',
      ),
      sigHashType.SIGHASH_ALL,
    )
    })
      .then(console.log)
      .catch(console.error)*/
  }).catch(e => {
    console.error(e)
    expect('lol').toBe(null)
  })
})
